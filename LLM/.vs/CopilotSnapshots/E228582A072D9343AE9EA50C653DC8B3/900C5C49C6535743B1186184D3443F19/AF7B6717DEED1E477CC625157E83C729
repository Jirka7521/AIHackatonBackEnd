using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Npgsql;
using System.Linq;
using System.Numerics;
using System.Globalization;

public class PostgresDatabase
{
    private readonly string _connectionString;

    public PostgresDatabase(string connectionString)
    {
        _connectionString = connectionString;
    }

    public async Task EnsureTableExistsAsync()
    {
        using var connection = new NpgsqlConnection(_connectionString);
        await connection.OpenAsync();

        // Attempt to create the pgvector extension.
        // On Azure, this may fail due to permission restrictions.
        string createExtension = "CREATE EXTENSION IF NOT EXISTS vector;";
        using (var extCommand = new NpgsqlCommand(createExtension, connection))
        {
            await extCommand.ExecuteNonQueryAsync();
        }

        // Execute the cosine_similarity function creation script.
        string createCosineSimilarity = System.IO.File.ReadAllText("CosineSimilarity.sql");
        using (var csCommand = new NpgsqlCommand(createCosineSimilarity, connection))
        {
            await csCommand.ExecuteNonQueryAsync();
        }

        // Create source_files table with identity column.
        string createSourceFiles = @"
            CREATE TABLE IF NOT EXISTS public.source_files
            (
                id integer NOT NULL GENERATED ALWAYS AS IDENTITY,
                file_path text COLLATE pg_catalog.""default"" NOT NULL,
                CONSTRAINT source_files_pkey PRIMARY KEY (id)
            );
        ";

        // Create vectors table with pgvector's vector type and snippet column.
        string createVectors = @"
            CREATE TABLE IF NOT EXISTS public.vectors
            (
                id integer NOT NULL GENERATED ALWAYS AS IDENTITY,
                source_file_id integer NOT NULL,
                vector_data vector(1536) NOT NULL,
                snippet text NOT NULL,
                CONSTRAINT vectors_pkey PRIMARY KEY (id),
                CONSTRAINT fk_source FOREIGN KEY (source_file_id)
                    REFERENCES public.source_files (id) MATCH SIMPLE
                    ON UPDATE NO ACTION
                    ON DELETE CASCADE
            );
        ";

        using (var command = new NpgsqlCommand(createSourceFiles, connection))
        {
            await command.ExecuteNonQueryAsync();
        }

        using (var command = new NpgsqlCommand(createVectors, connection))
        {
            await command.ExecuteNonQueryAsync();
        }
    }

    public async Task InsertPdfRecordAsync(PdfRecord record)
    {
        using var connection = new NpgsqlConnection(_connectionString);
        await connection.OpenAsync();

        // Check if the file already exists in source_files.
        string selectSourceFiles = @"
            SELECT id FROM public.source_files
            WHERE file_path = @file_path;
        ";

        int sourceFileId;
        using (var command = new NpgsqlCommand(selectSourceFiles, connection))
        {
            command.Parameters.AddWithValue("file_path", record.FileName);
            var result = await command.ExecuteScalarAsync();
            if (result != null)
            {
                sourceFileId = (int)result;
            }
            else
            {
                // Insert into source_files table to obtain a new id if not exists.
                string insertSourceFiles = @"
                    INSERT INTO public.source_files (file_path)
                    VALUES (@file_path)
                    RETURNING id;
                ";
                using var insertCommand = new NpgsqlCommand(insertSourceFiles, connection);
                insertCommand.Parameters.AddWithValue("file_path", record.FileName);
                sourceFileId = (int)await insertCommand.ExecuteScalarAsync();
            }
        }

        // Insert into vectors table using the obtained source_file id.
        string insertVectors = @"
            INSERT INTO public.vectors (source_file_id, vector_data, snippet)
            VALUES (@source_file_id, @vector_data, @snippet)
            ON CONFLICT DO NOTHING;
        ";

        using (var command = new NpgsqlCommand(insertVectors, connection))
        {
            command.Parameters.AddWithValue("source_file_id", sourceFileId);
            // Convert ReadOnlyMemory<float> to float[] since Npgsql expects an array of floats.
            command.Parameters.AddWithValue("vector_data", record.Vector.ToArray());
            command.Parameters.AddWithValue("snippet", record.Content);
            await command.ExecuteNonQueryAsync();
        }
    }

    public async Task PrintSourceFilesAsync()
    {
        using var connection = new NpgsqlConnection(_connectionString);
        await connection.OpenAsync();

        string query = "SELECT id, file_path FROM public.source_files;";
        using var command = new NpgsqlCommand(query, connection);
        using var reader = await command.ExecuteReaderAsync();

        Console.WriteLine("Contents of source_files:");
        while (await reader.ReadAsync())
        {
            int id = reader.GetInt32(0);
            string filePath = reader.GetString(1);
            Console.WriteLine($"  id: {id}, file_path: {filePath}");
        }
    }

    public async Task PrintVectorsAsync()
    {
        using var connection = new NpgsqlConnection(_connectionString);
        await connection.OpenAsync();

        // Cast the vector_data to text so we can read and parse it.
        string query = "SELECT id, source_file_id, vector_data::text, snippet FROM public.vectors;";
        using var command = new NpgsqlCommand(query, connection);
        using var reader = await command.ExecuteReaderAsync();

        Console.WriteLine("Contents of vectors:");
        while (await reader.ReadAsync())
        {
            int id = reader.GetInt32(0);
            int sourceFileId = reader.GetInt32(1);
            string vectorText = reader.GetString(2).Trim();
            string snippet = reader.GetString(3);

            float[] vectorData;
            if (vectorText.StartsWith("[") && vectorText.EndsWith("]"))
            {
                vectorData = vectorText.Trim('[', ']')
                                       .Split(',', StringSplitOptions.RemoveEmptyEntries)
                                       .Select(x => float.Parse(x.Trim(), CultureInfo.InvariantCulture))
                                       .ToArray();
            }
            else
            {
                // Handle single value scenario.
                vectorData = new float[] { float.Parse(vectorText, CultureInfo.InvariantCulture) };
            }

            string vectorStr = string.Join(", ", vectorData);
            Console.WriteLine($"  id: {id}, source_file_id: {sourceFileId}, vector_data: [{vectorStr}], snippet: {snippet}");
        }
    }

    public async Task<IEnumerable<(int Id, string FilePath, double Similarity)>> SearchSimilarVectorsAsync(ReadOnlyMemory<float> queryVector, int limit)
    {
        var results = new List<(int Id, string FilePath, double Similarity)>();
        using var connection = new NpgsqlConnection(_connectionString);
        await connection.OpenAsync();

        // This SQL query uses the custom cosine_similarity function to compute similarity.
        string sql = @"
            SELECT v.id, s.file_path, public.cosine_similarity(v.vector_data, @query) AS similarity
            FROM public.vectors v
            JOIN public.source_files s ON s.id = v.source_file_id
            ORDER BY public.cosine_similarity(v.vector_data, @query) DESC
            LIMIT @limit;
        ";

        using var command = new NpgsqlCommand(sql, connection);
        command.Parameters.AddWithValue("query", queryVector.ToArray());
        command.Parameters.AddWithValue("limit", limit);

        using var reader = await command.ExecuteReaderAsync();
        while (await reader.ReadAsync())
        {
            int id = reader.GetInt32(0);
            string filePath = reader.GetString(1);
            double similarity = reader.GetDouble(2);
            results.Add((id, filePath, similarity));
        }
        return results;
    }

    public async Task<PdfRecord?> GetPdfRecordByIdAsync(int id)
    {
        await using var conn = new NpgsqlConnection(_connectionString);
        await conn.OpenAsync();

        // Retrieve vector details along with the text snippet using a join between vectors and source_files.
        string query = @"
            SELECT v.id, s.file_path, v.snippet
            FROM public.vectors v
            JOIN public.source_files s ON s.id = v.source_file_id
            WHERE v.id = @id;
        ";
        await using var cmd = new NpgsqlCommand(query, conn);
        cmd.Parameters.AddWithValue("id", id);

        await using var reader = await cmd.ExecuteReaderAsync();
        if (await reader.ReadAsync())
        {
            var record = new PdfRecord
            {
                Id = reader.GetInt32(0),
                FileName = reader.GetString(1),
                Content = reader.GetString(2),
                // The vector field is not materialized here.
            };
            return record;
        }
        return null;
    }
}