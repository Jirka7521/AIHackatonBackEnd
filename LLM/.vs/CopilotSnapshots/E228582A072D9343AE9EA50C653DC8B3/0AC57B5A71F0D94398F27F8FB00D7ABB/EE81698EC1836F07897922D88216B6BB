using Azure;
using Azure.AI.OpenAI;
using Azure.Core;
using Microsoft.Extensions.AI;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Configuration.UserSecrets;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UglyToad.PdfPig;
using UglyToad.PdfPig.Content;

public class PdfRecord
{
    public int Id { get; set; }
    public string FileName { get; set; }
    public string Content { get; set; }
    public ReadOnlyMemory<float> Vector { get; set; }
}

/// <summary>
/// Represents the status of an operation.
/// </summary>
public enum OperationStatus
{
    Success,
    Error
}

/// <summary>
/// Represents the result of an operation including its status and a corresponding message.
/// </summary>
public class OperationResult
{
    public OperationStatus Status { get; set; }
    public string Message { get; set; }
}

/// <summary>
/// Represents a search result from the database vector search.
/// </summary>
public class DatabaseVectorSearchResult
{
    public int Id { get; set; }
    public string FileName { get; set; }
    public double Distance { get; set; }
}

/// <summary>
/// Provides public endpoints to interact with the vector store for PDF records, including initialization, 
/// vectorization of uploaded PDF files, and querying for relevant vectors using PostgreSQL database.
/// </summary>
public class VectorEndpoints
{
    private readonly IEmbeddingGenerator<string, Embedding<float>> _generator;
    private readonly PostgresDatabase _database;
    private int _nextId;

    private VectorEndpoints(IEmbeddingGenerator<string, Embedding<float>> generator, PostgresDatabase database)
    {
        _generator = generator;
        _nextId = 0;
        _database = database;
    }

    // Private factory method to encapsulate dependencies.
    private static async Task<VectorEndpoints> CreateInstanceAsync()
    {
        IConfiguration configuration = new ConfigurationBuilder()
            .AddJsonFile("appsettings.json", optional: false, reloadOnChange: true)
            .Build();

        string vectorEndpoint = configuration["AzureOpenAIVector:Endpoint"];
        string vectorModel = configuration["AzureOpenAIVector:Model"];
        string vectorApiKey = configuration["AzureOpenAIVector:ApiKey"];

        IEmbeddingGenerator<string, Embedding<float>> generator =
            new AzureOpenAIClient(new Uri(vectorEndpoint), new AzureKeyCredential(vectorApiKey))
                .GetEmbeddingClient(deploymentName: vectorModel)
                .AsIEmbeddingGenerator();

        string postgresConnectionString = configuration["Postgres:ConnectionString"];
        var database = new PostgresDatabase(postgresConnectionString);
        await database.EnsureTableExistsAsync();

        return new VectorEndpoints(generator, database);
    }

    /// <summary>
    /// Uploads a file, vectorizes its contents, and saves all vector chunks to the database.
    /// </summary>
    public static async Task<OperationResult> UploadFileAsync(string filePath)
    {
        if (string.IsNullOrWhiteSpace(filePath) || !File.Exists(filePath))
        {
            throw new ArgumentException("The file path is invalid or the file does not exist.", nameof(filePath));
        }

        VectorEndpoints instance = await CreateInstanceAsync();

        StringBuilder contentBuilder = new StringBuilder();
        using (PdfDocument pdf = PdfDocument.Open(filePath))
        {
            foreach (Page page in pdf.GetPages())
            {
                contentBuilder.AppendLine(page.Text);
            }
        }
        string pdfContent = contentBuilder.ToString().Normalize(NormalizationForm.FormC);

        // Split the content into chunks.
        const int chunkSize = 2000;
        List<string> chunks = new List<string>();
        for (int i = 0; i < pdfContent.Length; i += chunkSize)
        {
            int length = Math.Min(chunkSize, pdfContent.Length - i);
            chunks.Add(pdfContent.Substring(i, length));
        }

        int chunkId = instance._nextId;
        foreach (string chunk in chunks)
        {
            ReadOnlyMemory<float> vector = await instance._generator.GenerateVectorAsync(chunk);
            PdfRecord pdfRecord = new PdfRecord
            {
                Id = chunkId,
                FileName = filePath,
                Content = chunk,
                Vector = vector
            };

            await instance._database.InsertPdfRecordAsync(pdfRecord);
            chunkId++;
        }
        instance._nextId = chunkId;

        return new OperationResult
        {
            Status = OperationStatus.Success,
            Message = "File uploaded, vectorized, and persisted to database successfully."
        };
    }

    /// <summary>
    /// Searches for the n closest vectors to the query and returns their id and text.
    /// </summary>
    public static async Task<List<QueryResult>> QueryVectorsAsync(string query, int count)
    {
        if (string.IsNullOrWhiteSpace(query))
        {
            throw new ArgumentException("Query cannot be empty.", nameof(query));
        }
        if (count <= 0)
        {
            throw new ArgumentException("Count must be greater than zero.", nameof(count));
        }

        VectorEndpoints instance = await CreateInstanceAsync();

        ReadOnlyMemory<float> queryVector = await instance._generator.GenerateVectorAsync(query);
        var dbResults = await instance._database.SearchSimilarVectorsAsync(queryVector, count);

        // For each search result, retrieve the record to extract its text.
        var tasks = dbResults.Select(async r =>
        {
            var record = await instance._database.GetPdfRecordByIdAsync(r.Id);
            return new QueryResult
            {
                Id = r.Id,
                Text = record?.Content ?? string.Empty
            };
        });
        return (await Task.WhenAll(tasks)).ToList();
    }

    /// <summary>
    /// Retrieves the file path associated with the given vector id.
    /// </summary>
    public static async Task<string> GetFilePathAsync(int id)
    {
        VectorEndpoints instance = await CreateInstanceAsync();
        var record = await instance._database.GetPdfRecordByIdAsync(id);
        if (record is null)
        {
            throw new ArgumentException($"No vector found with id {id}", nameof(id));
        }
        return record.FileName;
    }
    // Simple model to return the query results.
    public class QueryResult
    {
        public int Id { get; set; }
        public string Text { get; set; }
    }
}